use std::fmt::Debug;
use houtamelo_utils::prelude::CountOrMore;
use serde::{Deserialize, Serialize};

/// The main output you'll receive when playing a Yarn node.
/// 
/// You'll receive an instruction each time you call `next` on a [compass](crate::prelude::YarnCompass).
/// 
/// It's up to you to decide how to handle each instruction.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum YarnInstruction<TCmd: Clone + PartialEq + Debug> {
	/// A regular dialogue line: "John: Hello world! #metadata"
	/// See [Speech](crate::prelude::Speech) for more details.
	Speech(Speech),
	/// ### A command defined by you, does not include <<set>> commands, those are handled directly by the coroutine.
	/// 
	/// # Rules for defining command types 
	/// ** The code generated by the proc-macro will not compile if you break any of these. **
	/// 
	/// - The command type **must** be an enum.
	/// - All variants need to be tuple-based. (`MyCommandType(String, i32)` is allowed but `MyCommandType { name: String, age: i32 }` is not)
	/// - All variants can only contain the following types: 
	///  - `String` (not &str or &'static str)
	///  - Any integer type: `i8`, `i16`, `i32`, `i64`, `isize`, `i128`, `u8`, `u16`, `u32`, `u64`, `usize`, `u128`
	///  - Any float type: `f32`, `f64`
	///  - Each variant's name needs to match the exact name (case sensitive) of the command invoked in the yarn script.
	/// 
	/// # Example of a valid command type
	/// 
	/// ```
	/// enum CustomCmd {
	///     FadeIn(i32),
	///     FadeOut(f32),
	///     PlayAnim(String),
	///     StopAnims,
	///     Sfx(String, f64),
	///     Music(String, f64),
	///     Jump(String), // The original YarnSpinner provides this command built-in, we don't.
	/// } 
	/// ```
	Command(TCmd),
	/// ### A list of choices for the player to pick from.
	/// See [ChoiceOption](crate::prelude::ChoiceOption) for more details.
	/// ___
	/// 
	/// 
	/// After receiving this instruction, the resulting compass will be a [ChoicesCompass](crate::prelude::ChoicesCompass),
	/// which requires that you provide a decision made by the player.
	/// 
	/// ___
	/// 
	/// The type `CountOrMore<1, ChoiceOption>` may seem weird, but it's just a [vector](std::vec::Vec) 
	/// that's guaranteed(at compile time!) to have at least one element.
	///
	/// 
	/// - Almost every single function implemented by [Vec](std::vec::Vec)
	/// is also implemented by [CountOrMore](houtamelo_utils::prelude::CountOrMore).
	/// - Slice-based operations are not implemented.
	///
	/// ___
	/// 
	/// ### To iterate through the options: 
	/// ```rs
	/// use yarn_spinner_aot::prelude::*;
	/// 
	/// fn handle_choices(compass: ChoicesCompass<_, _, _>) {
	///     compass.options()
	///            .for_each(|option| {
	///                 println!("{}", option.text);
	///             });
	/// }
	/// ```
	Choices(CountOrMore<1, ChoiceOption>),
}

/// Represents a single option the player can make,
/// these are made by the proc-macro based on the regular YarnSpinner syntax:
/// 
/// ```yarn
/// -> Option A
/// 	Option A results
/// -> Option B # option_b metadata
/// 	Option B results
/// ```
/// 
/// In this case, option A would be:
/// ChoiceOption {
///     metadata: None,
///     text: "Option A".to_string(),
/// }
/// 
/// And option B would be:
/// ChoiceOption {
///     metadata: Some("option_b metadata".to_string()),
///     text: "Option B".to_string(),
/// }
/// 
/// You'll receive this struct through a list in the [YarnInstruction::Choices](crate::prelude::YarnInstruction::Choices) enum.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ChoiceOption {
	/// The text representing the choice the player can make.
	/// 
	/// ___
	/// 
	/// ### Example
	/// Consider the line: `-> Jump off the cliff`
	/// 
	/// The text would be: `Jump off the cliff`
	pub text: String,
	/// The evaluated condition, if any.
	/// 
	/// This will only be `Some` if the option's line has a condition(`<<if [condition]>>`).
	/// 
	/// ___
	/// 
	/// # Example
	/// Consider the line: `-> Jump off the cliff <<if $player_has_parachute>>`
	/// 
	/// When reaching this line, the variable `player_has_parachute` will be fetched from the [VariableStorage](crate::prelude::VariableStorage), 
	///  making `is_available` be `Some(storage.get_var::<player_has_parachute>())`.
	/// 
	/// Note that, in this case, it is expected for the return value of `get_var::<player_has_parachute>()` to be a boolean,
	/// if it isn't, the code won't compile.
	/// 
	/// ___
	///
	/// # Usage
	/// - Although Evaluating the condition is done by YarnSpinner, it is up to the developer to decide what to do with the result,
	///  YarnSpinner will not forbid the player from picking an option even if it has a condition evaluated to `false`.
	/// - The `[condition]` argument can be any valid expression in the YarnSpinner syntax (`{5 + 3 > 8}`, `$player_awake and $gold > 10`, ...)
	pub is_available: Option<bool>,
	/// The metadata, if any.
	/// 
	/// A raw string that contains everything after the first unescaped `#` in the line.
	/// 
	/// ___
	/// 
	/// ### Example
	/// Consider the line: `-> Jump off the cliff # with parachute`
	/// 
	/// The metadata would be: `Some("with parachute")`
	pub metadata: Option<String>,
}

/// Represents a single line of dialogue,
/// these are made by the proc-macro based on the standard YarnSpinner syntax:
/// 
/// ```yarn
/// Houtamelo: This is the first line
/// Houtamelo: This is the second line # metadata
/// ```
/// 
/// In this case, the first line would be:
/// Speech {
///     speaker: Some("Houtamelo".to_string()),
///     text: "This is the first line".to_string(),
///     metadata: None,
/// }
/// 
/// And the second line would be:
/// Speech {
///     speaker: Some("Houtamelo".to_string()),
///     text: "This is the second line".to_string(),
///     metadata: Some("metadata".to_string()),
/// }
/// 
/// You'll receive this struct through the [YarnInstruction::Speech](crate::prelude::YarnInstruction::Speech) enum.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Speech {
	/// The name of the character that's speaking, if any.
	/// 
	/// ___
	/// 
	/// ### Example
	/// Consider the line: `Houtamelo: This is the first line`
	/// 
	/// The speaker would be: `Some("Houtamelo".to_string())`
	/// 
	/// Then consider the line: `$player_name: This is the first line`
	/// 
	/// The speaker would be: `Some(storage.get_var::<player_name>())`
	/// 
	/// On the case above, it is expected that `get_var::<player_name>()` returns a string, 
	/// if it doesn't, the code won't compile.
	pub speaker: Option<String>,
	/// What's being spoken.
	/// 
	/// ___
	/// 
	/// ### Example
	/// 
	/// Consider the line: `Houtamelo: This is the first line`
	/// 
	/// The text would be: `"This is the first line".to_string()`
	/// 
	/// Then consider the line: `Houtamelo: Hello there, {$player_name}!`
	/// 
	/// The text would be: `format!("Hello there, {}!".to_string(), storage.get_var::<player_name>())`
	/// 
	/// Unlike in `speaker`, the arguments inside the line can be anything that implements [Display](std::fmt::Display).
	/// 
	/// A line may have an unlimited amount of arguments, as long as each is a valid expression in the YarnSpinner syntax.
	pub text: String,
	/// The metadata, if any.
	/// 
	/// A raw string that contains everything after the first unescaped `#` in the line.
	/// 
	/// ___
	/// 
	/// ### Example
	/// Consider the line: `Houtamelo: This is the second line # all of this is metadata`
	/// 
	/// The metadata would be: `Some("all of this is metadata".to_string())`
	pub metadata: Option<String>,
}
